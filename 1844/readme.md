# A. [Subtraction Game](https://codeforces.com/problemset/problem/1844/A)

## 问题描述

一开始有n个石头，两个人玩游戏，轮到其中一个人的回合时，他可以选择把n-a或者n-b（a<b)。当轮到某人时，他无法移动（n<a），也就是他输了。求找到一个n，使得第二个人必赢。



## 问题思路

对n分类讨论：

n<a，一开始就小于a，那第一个玩家必输。

a<n<b，第二个人必输。

n>b，可以让n=a+b，那么第二个玩家必赢。



综上，答案就是a+b。

## 实现代码

```c++
#include<iostream>

int t, a, b;

void slv() {
	std::cin >> a >> b;
	
	std::cout << a + b << "\n";
}
int main() {
	std::cin >> t;
	while(t--) slv();
	return 0;
} 
```



## 要点

分类讨论



# B. [Permutations & Primes](https://codeforces.com/problemset/problem/1844/B)

## 问题描述

要求找一个长度n的全排列，满足全排列的子数组的MEX是质数的数量最大。



## 问题思路

对全排列的所有子数组分类讨论：



长度为1，显然只有一个子数组满足：[1]，MEX取到2。

长度为2，显然只有与1相邻的且值不为2才满足：[1,x]，MEX取到2。



到这里我们发现了一个性质：子数组必须包含1，这样MEX才会取到大于1的数。

于是我们只对包含1的子数组分类讨论：



长度为3，显然只要这个子数组不包含2就满足要求，MEX取到2。

长度为4，同上。

...

长度为n，这取决于n+1是否是质数，与排列本身无影响。



到这里，讨论结束。综上，我们应该让1与2的距离尽可能离得远，这并不是指单纯地把1放在最左边、2放在最右边，这种情况下，数量只有n-1。而是尝试把1放在中间，2放在数组最后：



n是奇数

​	n=2k+1, 不包含2，1左边有k个数，右边有k-1个数，总共有k*(k+1)种满足题意，显然大于2k。

​				包含2，此时只要把3放在最左边即可。

n是偶数

​	n=2k+2, 不包含2，1左边有k个数，右边有k个数，总共有(k+1)(k+1)种满足题意，显然大于2k+1。

​				包含2，此时只要把3放在最左边即可。



综上，n<3直接按照顺序输出结果，否则从小到大的3个数分别与索引(n-1)/2+1，n，1交换。

## 实现代码

```c++
#include<iostream>

int t, n;
void slv() {
	std::cin >> n;
	
	if(n > 2) {
		int x = 4, p = (n-1)/2+1;
		
		std::cout << "2 ";
		for(int i = 2; i < n; i++) {
			if(i != p) {
				std::cout << x << " ";
				x++; 
			} else {
				std::cout << "1 ";			
			}
		}
		std::cout << "3 ";
	} else {
		for(int i = 1; i <= n; i++) {
			std::cout << i << " ";	
		}
	}
	std::cout << "\n";
}

int main() {
	std::cin >> t;
	while(t--) slv();
	return 0;
}
```



## 要点

分类讨论



# D. [Row Major](https://codeforces.com/problemset/problem/1844/D)

## 问题描述

构造一个长度n的字符串，使得即使把字符串转换成r×c的字符矩阵，相邻的字符依旧不同。同时这个字符串用到的不同字符需要最少。



## 问题思路

分类讨论：

n=1，略。

n=2，至少2个不同字符。

n=3，是质数，只要相邻的不同即可，也就是只需要2个不同字符。

n=4，有1×4，2×2：a[i]!=a[i-1]且a[i]!=a[i-2]

n=5，是质数，同3。

n=6，有1×6，2×3，3×2：一个要求相邻不同，一个要求a[i]!=a[i-3]，一个要求a[i]!=a[i-2]。



列了6项，大概发现与因数分解有关：

结论：相邻的字符依旧不同这一限制条件等价于，把n因数分解得到数组b，对字符串必须满足a[i]!=a[i-b[i]]（包括1不包括数组长度n）。



到这里依然并不好办，因为这题数据量比较大，循环内使用因数分解很勉强。我们需要把问题再优化一下。

到目前为止，我们得到的都是a[i]与a[i-b[i]]的不相等关系，那么如果从相等出手，这题会不会变得简单呢？



考虑到b[i]都是n的因数，也就是存在最小值c使得n不被c整除。



不被整除意味着没必要满足a[i]!=a[i-c]，这里贪心地处理可以让所有a[i]=a[i-c]。

于是我们得到一个**以c为周期**的循环字符串，并且c显然是这个字符串的不同字符的最小值。通过这个周期性的特点，可以对代码再次优化，使代码变得简洁，时间复杂度也是线性。



## 实现代码

```c++
#include<iostream>
int t, n;

void slv() {
	std::cin >> n;
	
	int x = 2;
	while(n % x == 0) x++;
	
	for(int i = 0; i < n; i++) {
		char ch = 'a' + (i % x);
		std::cout << ch;
	}
	std::cout << "\n";
}

int main() {
	std::cin >> t;
	while(t--) slv();
	return 0;
}
```



## 要点

分类讨论