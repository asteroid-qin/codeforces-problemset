# A. [Number of Apartments](https://codeforces.com/problemset/problem/1430/A)

## 问题描述

给定整数n，要求找三个非负整数：x、y、z，满足：3x+5y+7z=n。



注意！n<1000

## 问题思路

注意到n<1000，所以可以暴力枚举5和7，只要中间的值能被3整除，就代表找到了一对。



因为可以短路，所以并不会超时。于是可以写下第一版的代码。



但是升级一下，假设n的值是<100000呢？这样就有风险了，需要对算法优化下。

可以对3分类：

1. 被3整除。那么直接输出：n/3 0 0。
2. 被3除余1。注意到7除3余1，所以可以先-7，那么原本多出来的1被去掉了。所以可以输出：(n-7)/3 0 1。
3. 被3除余2。注意到5除3余2，所以可以先-5，那么原本多出来的2被去掉了。所以可以输出：(n-5)/3 1 0。



按照上面实现即可，因为非常简单就不写了。

## 实现代码

```c++
#include<iostream>

int n, t;
int x, y, z;

bool check() {
	for(int i = 0; i <= 1000 && 7 * i <= n; i++) {
		for(int j = 0; j <= 1000 && 7 * i + 5 * j <= n; j++) {
			if((n - 7 * i - 5 * j) % 3 == 0) {
				x = (n - 7 * i - 5 * j) / 3;
				y = j;
				z = i;
				return true;
			}
		}
	}
	return false;
} 
int main() {
	std::cin >> t;
	while(t--) {
		std::cin >> n;
		if(check()) std::cout << x << " " << y << " " << z << "\n";
		else std::cout << "-1\n";
	}
	return 0;
} 
```



## 要点

注意到数据范围、暴力模拟、断路、数论（优化）



# C. [Numbers on Whiteboard](https://codeforces.com/problemset/problem/1430/C)

## 问题描述

给定长度n的数组a，a的元素从前往后依次是1到n。现在可以执行n-1次操作，每次操作需要先选择2个数，然后把它们替换为向上取整的算术平均值。



现在要求输出n-1步时选择的数，使得剩下的最后一个数最小。

## 问题思路

注意到答案的最小是，所以得想办法总是得到2。



正常暴力得不出解，所以得找规律。注意到a的一个重要性质：连续的！而 n -2 n-1 n 可以快速变换为n-1。



所以假设有：

1 2 3 ... n-7 n-6 n-5 n-4 n-3 n-2 n-1 n



先n+n-2再/2，得到n-1，再把两个n-1求和再/2得到：

1 2 3 ... n-7 n-6 n-5 n-4 n-3 n-1 

此时n-1+ n-3再/2，得到：

1 2 3 ... n-7 n-6 n-5 n-4 n-2

此时n-4+ n-2再/2，得到：

1 2 3 ... n-7 n-6 n-5 n-3

...

这样一直做下去，发现会得到：

1 2 3 5

此时3+5再/2，得到：

1 2 4

此时2+4再/2，得到：

1 3

此时1+3再/2，得到我们最终想要的结果：2



通过模拟这个过程，我们得到一条完美的构造方法：

先打印 n n-2和 n-1 n-1

再倒着打印i i+2，i从n-3开始，在1结束。



使用代码模拟上面这个过程即可。

## 实现代码

```c++
#include<iostream>

int n, t;

int main() {
	std::cin >> t;
	while(t--) {
		std::cin >> n;
		
		std::cout << "2\n";
		if(n == 2) {
			std::cout << "1 2\n";
			continue;
		} 
		
		std::cout << n << " " << n - 2 << "\n";
		std::cout << n - 1 << " " << n - 1 << "\n";
		for(int i = n - 3; i >= 1; i--) {
			std::cout << i << " " << i + 2 << "\n";
 		}
	}
	return 0;
} 
```



## 要点

找规律、得到关键结论