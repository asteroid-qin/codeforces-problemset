# B. [Nastya Is Playing Computer Games](https://codeforces.com/problemset/problem/1136/B)

## 问题描述

给定长度n的数组a，a中所有元素都是1。一开始选择索引i等于k。每轮有3种操作可以选择：

1. 将a[i] - 1，同时a[i+1] + 1或者 同时a[i-1] + 1
2. i++，或者i--
3. 如果a[i]=0且是第一次等于0，那么tot++



选择求：使得tot=n的最小轮数



## 问题思路

这里，下标移动不确定（和k的值有关），每个索引i的a[i]-- 至少1次，采集固定1次。因此除了移动，我们应该使得a[i]--的次数最少。



这里猜想为：先从k移动到最近的点1或者n，然后再输出3 * n即可。



先说说为什么是3 * n，因为此时点是1或者n，所以下标只需要移动1次，索引处的a[i]-- 可以1次搞定，采集也固定一次。因此轮数为3 * n。

再说为什么是1或者n（两端）

假设k=1，n=3。则从索引1到2路上有：

1 1 1=> 0 2 1 => 2 0 1

可以看到，从3开始，每个1向左移动，也就是a[i]--的开销最小化。



而如果在半路上开始移动：

假设k=3，n=5。则有

1 1 1 1 1 => 1 1 2 0 1  =>1 1 0 2 1

可以看到与从两端开始移动比较起来，在中间移动会导致0 2出现的次数要算1次，所以从两端最优。



总结：

输出：min(k-1, n-k)+3*n

## 实现代码

```c++
#include<iostream>

int n, k;
int main() {
	std::cin >> n >> k;
	std::cout << std::min(k-1, n-k) + 3 * n << "\n";
	return 0;
}
```



## 要点

贪心