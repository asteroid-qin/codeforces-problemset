# A. [Little Artem](https://codeforces.com/problemset/problem/1333/A)

## 问题描述

给定整数n和m，要求构造一个值是0或1的n行m列的二维数组a（原题指的是白色与黑色）。

定义B：所有周围至少有1个0的1的个数

定义W：所有周围至少有1个1的0的个数



要求a满足：B=W+1



## 问题思路

就像是所有在堆中的元素都会有一个默认值一样，这里可以让a初始值是1。此时a的B=W=0。

现在需要做的操作是把一些1变为0，注意到：

1. 在非边缘处把1变成0，会使得： B最多+4，W最多+1

2. 在边缘处非角落里把1变成0，会使得：B最多加+3，W最多+1

3. 在角落里把1变成0，会使得：B最多加+2，W最多+1



注意到角落的操作会使得B+2，W+1。在一开始B=W=0，执行操作后B=2，W=1，这是满足题目要求的！



因此，我们可以处理第1行第1列输出0，其他都输出1（解决原题则是，第一行第一列输出'W'，其他输出'B'）



## 实现代码

```c++
#include<iostream>

int t, n, m;
int main() {
	std::cin >> t;
	while(t--) {
		std::cin >> n >> m;
		
		for(int i = 1; i <= n; i++) {
			for(int j = 1; j <= m; j++) {
				if(i == 1 && j == 1) std::cout << "W";
				else std::cout << "B";
			}
			std::cout << "\n";
		}
	}
	return 0;
} 
```



## 要点

从B=W=0时出发，意识到一次角落的翻转操作就满足要求