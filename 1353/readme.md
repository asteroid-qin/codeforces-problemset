# A. [Most Unstable Array](https://codeforces.com/problemset/problem/1353/A)

## 问题描述

给定整数n和m，要求构造长度n的数组a，满足：

1. a中元素都 >= 0
2. a中元素的和等于m
3. a中相邻元素的差的绝对值的和最大



最后输出这个最大值即可。**不需要输出a**

## 问题思路

对n的长度分类讨论：

当n=1时，差的绝对值的最大和自然只能是0

当n=2时，可以遍历n*n种可能发现最大值只能是n

当n=3时，可以遍历n * n * n 种可能，发现最大值是2 * m：也就是m放在中间，左右为0

当n=4时，可以遍历n * n * n * n种可能，发现最大值是：2 * m: 也就是 0 m 0 0

当n=5时，可以遍历n * n * n * n * n种可能，发现最大值是: 2 * m: 也就是 0 m 0 0 0

...

到这里，通过打表找规律，我们已经有一个大胆的猜测：n大于2的情况下，差的绝对值的和最大不超过2 * m



简单的证明如下：

假设 0 m 0 0 ... 0的构造不是最优，那么可以从m中取出a，再来随意地放置a。

注意到，如果a也是放在左右为0的位置，那么它可以贡献2a，但是它们的和依旧是2*m。且如果a放在非左右为0的位置，这个和的值一定会比2 * m的值要小。



因此把m拆成2部分的时，它的和不超过 2* m

那么把m拆成3部分的时候呢？显然3部分可以由2部分转换，所以它的和绝对不大于原本2部分的，既然2部分的时候都比原来的要少，所以3部分的和也不超过2 * m。

同理把m拆成4部分、5部分，乃至拆成n部分也是如此（如果可以的话）。



总结：

1. n为1时，输出0
2. n为2时，输出m
3. 否则，输出m*2



## 实现代码

```c++
#include<iostream>

int t, n, m;
int main() {
	std::cin >> t;
	while(t--) {
		std::cin >> n >> m;
		
		int ans;
		if(n == 1) {
			ans = 0;
		} else if(n == 2) {
			ans = m;
		} else {
			ans = m * 2;
		}
		std::cout << ans << "\n";
	}
	return 0;
}
```





## 要点

数学差，只能打表找规律：最大不超过2 * m
