# B. [Mark the Dust Sweeper](https://codeforces.com/problemset/problem/1705/B)

## 问题描述

给长度n的每个数都>=0的数组a，有一个操作：选择下标i和j（i<j），如果$$a_i$$到$$a_{j-1}$$都严格大于0， 则ai-1并且aj+1。现在求让数组a除了最后一项全为0的最小操作。



## 问题思路

注意到严格大于0的范围，发现对a[j]的值无关心。因此可以从左往右操作。

如果a[i]==0，则跳过。否则，a[i]-1，a[i+1]+1，直到a[i]=0，显然这需要执行a[i]次，同时a[i+1]在原来的基础上加了a[i]。

i++，回到上一步，如此反复，直到i到n-1执行完毕。



但是这样做并不满足最少，因为它使得a[i+1]+1了。换种思路：

如果a[i]!=0，则求后面0的个数：可以把它们填1！这样后续所有操作只需要对a[i]求和即可，因为把j选作n-1!



但是为什么这是最少呢？如果一个0放在中间导致阶段，因为一定是从左往右清零，所以这个过程0必然会被填充到大于0。因此可以提前把这一操作做了！而后续操作绝对是最优的。因此这样便是最少的！



## 实现代码

```c++
#include<iostream>

int t, n, a[200000];
int main() {
	std::cin >> t;
	while(t--) {
		std::cin >> n;
		
		for(int i = 0; i < n;i++) {
			std::cin >> a[i];
		}
		
		// 跳过所有0 
		int i = 0;
		while(i < n-1 && a[i] == 0) i++;
		
		// 否则计算其中0的个数并算答案 
		long long ans = 0;
		while(i < n-1) {
			if(a[i] == 0) ans++;
			else ans += a[i];
			
			i++;
		}
		
		std::cout << ans << "\n";
	}
	
	return 0;
}
```





## 要点

从左往右，贪心