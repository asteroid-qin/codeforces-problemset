# A. [Permutation Forgery](https://codeforces.com/problemset/problem/1405/A)

## 问题描述

给定长度n的元素是从1到n的全排列数组a，要求输出一个和a不同的全排列b，满足：

a的相邻和得到的长度n-1数组，与b通过同样操作得到的数组是相等的（不考虑顺序）



## 问题思路

当n=1时，是无解的。

当n=2时，需要颠倒 a1 a2的顺序，得到数组a。

当n=3时，a得到 a1+a2 a2+a3。

b可以是：

a1 a3 a2 => a1+a3 a2+a3

a2 a1 a3=>a1+a2 a1+a3

a2 a3 a1=>a2+a3 a3+a1

a3 a1 a2=>a3+a1 a1+a2

a3 a2 a1=>a3+a2 a2+a1



整理发现，计算存在特殊情况，b也至少有一种可能：a3 a2 a1。



而这就是解题的关键：我们只需要把数组a颠倒打印即可。



那么这个n=3的特例，可以推广到任意自然数吗？

答案是显然的，倒着打印无非是从右往左数，和a从左往右数得到的数组是可以一一对应的。



## 实现代码

```c++
#include<iostream>

int t, n, a[101];
int main(){
	std::cin >> t;
	while(t--) {
		std::cin >> n;
		for(int i = 0; i < n; i++) std::cin >> a[i];
		
		for(int i = 0; i < n; i++) std::cout << a[n-1-i] << " ";
		std::cout << "\n";
	}
	return 0;
} 
```



## 要点

纯思维



# B. [Array Cancellation](https://codeforces.com/problemset/problem/1405/B)

## 问题描述

给定长度n的数组a，数组a满足和等于0。

现在可以执行任意次操作：选择i，j，然后a[i]--, a[j]++。如果i < j，那么操作免费，否则花费1.



现在要求使得数组a中所有元素为0的最小花费。

## 问题思路

一个--，另个++，这应该想起差分和前缀和，而解决这道问题的关键就是利用前缀和。

定义sum[i] 是 1到 i 的a[i]的和，当我们尝试对i，j操作时，sum数组的变化是：[i, j-1]区间所有元素都会+1或者-1。



换句话说，对区间的-1都是免费的，对区间的+1都是1花费。原本分散的2个点的操作，可以转换为1段区间的操作。问题变成了：可以对区间+1或者-1（+1开销1），现在问让数组所有元素为0的最小开销。



当数组全是正数，因为-1都是免费的，显然输出0.

当数组有负数呢？显然可以先把所有的正数变为0，先处理所有的负数。处理负数每次都需要1开销，因此我们一整个数组地处理，这样开销只会是数组中负数的绝对值的最大值。这样操作可能会导出出现不连续的正数，但又因为-1是免费的，所以不需要关心。



综上：输出前缀和数组的负数绝对值的最大值。

## 实现代码

```c++
#include<iostream>

int t, n;
int main(){
	std::cin >> t;
	while(t--) {
		std::cin >> n;
		
		long long cur = 0, sum = 0;
		for(int i = 0; i < n; i++) {
			int x; std::cin >> x;
			sum += x;
			cur = std::max(cur, sum * -1);
		}
		std::cout << cur << "\n";
	}
	return 0;
} 
```



## 要点

前缀和



