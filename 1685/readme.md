# A. [Circular Local MiniMax](https://codeforces.com/problemset/problem/1685/A)

## 问题描述

给定长度n的整数数组a，要求重新排序得到一个b，b满足：

1. 对于所有的i，满足b[i-1] < b[i] > b[i+1] 或者 b[i-1] > b[i] < b[i+1]



对于索引从1开始，b[0] = b[n]，b[n+1] = b[1]。



## 问题思路

不妨令 b[n] < b[1] > b[2]，显然这个关系会交替传递下去：

b[1] > b[2] < b[3]

b[1] < b[3] > b[3]

b[1] > b[4] < b[3]

b[1] < b[5] > b[3]

b[1] > b[2] < b[3]

...



于是会有1个结论：

1. 奇数索引的值必然比左右要大，和偶数索引必然比左右要小



那么n能是奇数吗？如果n是奇数，那它比左右要大，因此它大于a[1]，但是这和最开始假设b[n] < b[1] 矛盾，因此n必须是偶数。同理可以证明，b[n] > b[1] < b[2] 时开始，n也必须是偶数。



小总结，n是奇数无解



接下来开始往b上放元素，可以尝试先放最大值，因为没有人比它更大，所以它可以放在索引1处。

接下来考虑次大值，如果它放在索引2处，因为索引3一定不会比次大值还大，所以舍去。因此次大值最好和最大值隔一个再放。

后面都是如此，考虑从大到小，分别放在奇数索引上。



因为n是偶数，不妨令n=2m，那么放在奇数索引上的数一定有m个，且是m个最大的值。



现在继续剩下m个比较小的值，此时应该贪心地把最小值放在，m个最大的值的最小值的后面；把剩下的最大值放在，m个最大的值的最大值的后面。这样一定是最优的。



但是有没有可能依旧没有解呢？考虑一种情况，排序a[i]得到a[i] <= a[i+1]后，如果有m个以上的元素相等，那么肯定会没有解。当然可不可以直接这么写呢？这就不晓得了。



总之，按照最优的方法去模拟即可，如果担心没有解决，那就最后再校验下。



## 实现代码

```c++
#include<iostream>
#include<algorithm>

int t, n, a[100001], b[100001];

void slv() {
	std::cin >> n;
	for(int i = 0; i < n; i++) {
		std::cin >> a[i];
	}
	
	if(n&1) {
		std::cout << "NO\n";
		return; 
	}
	
	std::sort(a,a+n);
	
	int m = n / 2;
	
	for(int i = 0; i < n; i += 2) {
		b[i] = a[n - i - 1];
		b[i+1] = a[n - i - 1- m];
	}
	for(int i = 0; i < m; i++) {
		b[i*2] = a[n - i - 1];  
		b[i*2 + 1] = a[n - i - 1 - m];
	}
	
	for(int i = 0; i < n; i += 2) {
		int x = b[(i-1+n)%n];
		int y = b[(i+1)%n];
		if(x >= b[i] || y >= b[i]) {
			std::cout << "NO\n";
			return; 
		}
	}	
	
	for(int i = 1; i < n; i += 2) {
		int x = b[(i-1+n)%n];
		int y = b[(i+1)%n];
		if(x <= b[i] || y <= b[i]) {
			std::cout << "NO\n";
			return; 
		}
	}
	
	std::cout << "YES\n";
	for(int i = 0; i < n; i++) {
		std::cout << b[i] << " ";
	}
}

int main() {
	std::cin >> t;
	while(t--) {
		slv(); 
	}
	return 0;
} 
```



## 要点

排序后，输出：a[2 * m] a[1] a[2 * m-1] a[2] a[2 * m - 2] a[3] ...