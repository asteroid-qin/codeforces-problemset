# A. [Binary Imbalance](https://codeforces.com/problemset/problem/1902/A)

## 问题描述

给定长度n的01字符串s，可以执行任意次操作：

1. 选择[1, n-1]的索引i，如果s[i] = s[i+1]，那么往s[i]与s[i+1]之间放入一个字符'1'。否则放入一个字符'0'。



现在问，能否让s中'0'字符出现的次数严格大于'1'字符出现的次数。



## 问题思路

对于一个相邻的元素a b分类讨论：



如果a!=b，那么需要往a和b中间插入一个字符'0'。

显然a、b中必然有一个是'1'，所以又构成了一个新的不等于，这又回到了初始的情况。



因此：如果a != b，那么我们可以放无穷的'0'，使得'0'出现的次数严格大于'1'



既然存在两个相邻元素不等，就可以输出 "YES"。那么反过来呢？

如果任意两个相邻元素相等，也就是要么全为'0'，要么全为'1'。



如果全为'0'，根据题目，我们可以放入1个'1'。这样出现了两个相邻元素不等于，因此输出"YES"

如果全为'1'，我们只能继续放'1'，显然无论如何都无法增加'0'的数量，所以只能输出"NO"



总结：

如果s全是1则输出 NO，否则输出YES



## 实现代码

```c++
#include<iostream>

int n, t;
std::string s; 

int main() {
	std::cin >> t;
	while(t--) {
		std::cin >> n >> s;
		
		if(s == std::string(n, '1')) {
			std::cout << "NO\n";
		} else {
			std::cout << "YES\n";
		}
	}
	
	return 0;
} 
```



## 要点

存在两个相邻元素不等，那么我们可以放无穷的'0'，使得'0'出现的次数严格大于'1'