# B. [AND Sorting](https://codeforces.com/problemset/problem/1682/B)

## 问题描述

给定长度n的1到n-1的全排列a，定义X排序：

1. 选择2个索引 i 和j，并且 a[i] & a[j] = X
2. 交换a[i] a[j]



现在求能让a递增的最大X



## 问题思路

想想看，如果a[0] != 0会发生什么？

因为无论如何都得把0交换过来，所以会 & 0 至少1次，因此X最大只能为0。



想想看，如果a[1] != 1会发生什么？

因为至少 & 1 一次，所以X最大只能是为1。



注意到，我们可以从0循环到n-1，对于当前a[i]：

如果a[i] !=i，那么必须让 i 换到 i 处，假设 a[j] = i，也就是得交换a[i]和a[j]才行。



所以X = a[i] & a[j]。那么可不可以加一个中转呢？比方说有1个k，我们先 交换a[j] 和 a[k]，再交换a[k] 和a[i]。注意到这个过程中，要满足：

a[j] & a[k] = X 和 a[k] & a[i] =X。



也就是：如果X化作2进制的某一位是1，那么这1位必须a[j]、a[k]、a[i] 都是1才行！而如果只是交换a[i]和a[j]，那么只需要a[i]和a[j]那1位都是1就足够了。

所以：不应该引入中转，而是直接交换。



总结，用b表示，b[a[i]] = i，

于是循环i，从0到n-1：

如果 i != a[i] ，那么 a[i] & a[b[i]] = X。



又因为a[i] != i，在i处会执行一次，在 b[i]处又会执行一遍，所以不妨舍弃这个b：直接X &= a[i]。



最后考虑X的初始值。

假设有k个a[i] != i的索引，得到数组c。



把X和c[i]都化作2进制数，考虑X的取值。



如果X的j位想要取1，那么每个 c[i] [j] = 1，只要其中一个这1为0，那么 X 这位就是0。

所以我们只需要 & 上 c[i] 即可（所有的）



至于X的初始值，那肯定最好每位都是1（二进制），考虑数据范围取X= 2^30 - 1。



总结：

初始话ans=2^30-1，循环i，从0到n-1：

​	如果i != a[i]，那么 ans &= i

最后输出ans，作为答案



## 实现代码

```c++
#include<iostream>

int t, n, a[200001]; 

int main() {
	std::cin >> t;
	while(t--) {
		std::cin >> n;
		for(int i = 0; i < n; i++) {
			std::cin >> a[i];
		}
		
		
		int ans = (1 << 30 ) - 1;
		for(int i = 0; i < n; i++) {
			if(i == a[i]) continue;
			ans &= i;
		}
		
		std::cout << ans << "\n";
	}
	return 0;
}
```



## 要点

从第1位（0）开始，从前往后贪心地考虑