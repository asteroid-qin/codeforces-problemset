# B. [Madoka and Underground Competitions](https://codeforces.com/problemset/problem/1717/B)

## 问题描述

给定n 行 n列的矩阵a，a由'X'或'.'组成。现在要求自己构造这个a，满足：

1. a的所有1行k列和k行1列的子矩阵，必须至少有1个'X'
2. a的'X'数量尽可能最小
3. a[r] [c] = 'X'



## 问题思路

仁慈的样例3，一般人看了都会有一个大胆的想法



a一开始全部都是'.'，现在想办法放'X'。

从a[r] [c] 开始，r++，c++，让这一条斜线上所有的元素的值都是'X'。

但是问题还没有结束，这个斜线可能出现多次且每条斜线的距离应该是k。



那么什么点应该画斜线呢？

假设这个点是x,y，如果x=r，那么只有满足y是 ：(y-c)%k=0，才应该选择，这条公式很好，但是它只适用于x=r的情况，我们需要想办法求出每行对应的c值（如果向上移动，c值也会相应的变化）。

我们可以用b来维护每一行的x=>通过x快速求出这一行的c。

对于当前行，如果(y-b[x])%k=0，那么a[x] [y] = 'X'，否则a[x] [y] = '.'。



现在问题就变为了如何求出b？显然，我们只需要从r，c点分别向上和向下算即可。我们不关心b[i]的值大于n还是小于0，因为只需要取模即可。



总结：

从点(r,c)向上和向下，求出每行对应的c值，定义b[i] = 第i行对应的c值。

循环整个a，设当前坐标为(x,y)，如果 (y-b[x])%k=0，那么输出'X'否则输出'.'





### 实现代码

```c++
#include<iostream>

int t, n, k, r, c, a[501];

int main() {
	std::cin >> t;
	while(t--) {
		std::cin >> n >> k >> r >> c;
		
		for(int p = r, q = c; p >= 1; p--, q++) {
			a[p] = q;
		}
		
		for(int p = r, q = c; p <= n; p++, q--) {
			a[p] = q;
		}
		
		for(int i = 1; i <= n; i++) {
			for(int j = 1; j <= n; j++) {
				if((j - a[i]) % k == 0) std::cout << "X";
				else std::cout << ".";
			}
			std::cout << "\n";
		}
	}
	return 0;
}
```



## 要点

模拟