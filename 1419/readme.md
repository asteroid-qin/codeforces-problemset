# D1. [Sage's Birthday (easy version)](https://codeforces.com/problemset/problem/1419/D1)

## 问题描述

给定长度n的整数数组a，要求重新排列，使得：比左右要小的数出现最多。



## 问题思路

贪心的想，我们应该尝试从小到大选择作为比左右要小的数。

所以可以对数组排个序。



现在问，这个最多能取掉几？答案是：(n-1)/2。

简单证明如下：

取1的情况，显然至少要有3个数。

取2的情况，显然至少要有5个数。

取3的情况，显然至少要有7个数。

...

可以用数学归纳法证明：取k个数的情况，至少要有k*2+1个数。

也就是当只有n个数时，最多能取：(n-1)/2。



===============================

为了达到理论最大值，我们贪心地选择数组a的(n-1)/2个最小值。因为是递增排序后的，而无重复，所以(n-1)/2以后的数都比前面任意一个大。反之就是前(n-1)/2个，每个最小值都能贡献价值。它们的贡献价值的和就是理论最大值(n-1)/2。



可以对n分类讨论：



n为奇数时，n=2k+1，那么把 前 k个最小值和后k+1个最大值分开。

可以尝试从1开始放最小值，每次索引 + 2，

再继续从0开始放最大值，每次索引+2，

发现刚好把所有最小值给包裹了。这个被包裹的数量为k，也就是(n-1)/2



代码按照这个思路很好实现。



n为偶数时，n=2k，那么把 前k-1个最小值和后k+1个最大值分开。

继续先从1开始放最小值，每次索引+2，

再继续从0开始放最大值，每次索引+2，

完美包裹k-1个数只需要k个数，所以会多出一个数。我们把它放在数组的最后面即可。

这种情况下，被包裹的数量为k-1，也就是(n-1)/2



到这里结束。只需要把最小值和最大值分开，再合并，最后对偶数特判即可。



## 实现代码

```c++
#include<iostream>
#include<algorithm>

int n, t, a[100002], b[100002];

void slv() {
	std::cin >> n;
	for(int i = 0; i < n; i++) std::cin>> a[i];

	std::sort(a, a+n);
	int k = (n - 1) / 2;
	std::cout << k << "\n";
	
	for(int i = 0, j = 1; i < k; i++, j +=2) {
		b[j] = a[i];
	}
	for(int i = k, j = 0; i < n; i++, j +=2) {
		b[j] = a[i];
	}
	
	if(n % 2==0) b[n-1] = a[n-1];
	
	for(int i = 0 ; i < n; i++) {
		std::cout << b[i] << " ";
	}
	std::cout << "\n";
}

int main() {
	t = 1;
//	std::cin >> t;
	while(t--) slv();
	return 0;
} 
```



## 要点

贪心